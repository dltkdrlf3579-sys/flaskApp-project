# ============= Follow SOP 페이지 라우트 =============
@app.route("/follow-sop")
def follow_sop_route():
    """Follow SOP 페이지 라우트"""
    from common_mapping import smart_apply_mappings
    import math
    import sqlite3
    from section_service import SectionConfigService
    
    conn = get_db_connection()
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # 섹션 서비스 초기화
    section_service = SectionConfigService('follow_sop', DB_PATH)
    
    # 기본 섹션 확인 및 생성
    cursor.execute("SELECT COUNT(*) FROM follow_sop_sections WHERE section_key = 'basic_info'")
    if cursor.fetchone()[0] == 0:
        cursor.execute("""
            INSERT INTO follow_sop_sections (section_key, section_name, section_order, is_active)
            VALUES ('basic_info', '기본정보', 1, 1)
        """)
        conn.commit()
    
    # 섹션 정보 가져오기
    sections = section_service.get_sections()
    
    # 동적 컬럼 정보 가져오기
    cursor.execute("""
        SELECT * FROM follow_sop_column_config 
        WHERE is_active = 1 AND (is_deleted = 0 OR is_deleted IS NULL)
        ORDER BY column_order
    """)
    dynamic_columns_rows = cursor.fetchall()
    dynamic_columns = [dict(row) for row in dynamic_columns_rows]
    
    # 섹션별로 컬럼 분류
    section_columns = {}
    for section in sections:
        section_columns[section['section_key']] = [
            col for col in dynamic_columns if col.get('tab') == section['section_key']
        ]
    
    # 페이지네이션 처리
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    
    # 검색 조건 처리
    search_params = {}
    where_clauses = []
    query_params = []
    
    # 기본 검색 필드들
    company_name = request.args.get('company_name', '').strip()
    business_number = request.args.get('business_number', '').strip()
    
    if company_name:
        search_params['company_name'] = company_name
        where_clauses.append("JSON_EXTRACT(s.custom_data, '$.company_name_1cha') LIKE ?")
        query_params.append(f"%{company_name}%")
    
    if business_number:
        search_params['business_number'] = business_number
        where_clauses.append("JSON_EXTRACT(s.custom_data, '$.company_name_1cha_bizno') LIKE ?")
        query_params.append(f"%{business_number}%")
    
    # WHERE 절 구성 (삭제되지 않은 항목만)
    where_clauses.insert(0, "(s.is_deleted = 0 OR s.is_deleted IS NULL)")
    where_sql = " AND ".join(where_clauses) if where_clauses else "1=1"
    
    # 전체 건수 조회 - follow_sop_cache 테이블에서!
    count_query = f"""
        SELECT COUNT(*) 
        FROM follow_sop_cache s
        WHERE {where_sql}
    """
    
    cursor.execute(count_query, query_params)
    total_count = cursor.fetchone()[0]
    
    # 데이터 조회 - follow_sop_cache 테이블에서!
    query = f"""
        SELECT s.* 
        FROM follow_sop_cache s
        WHERE {where_sql}
        ORDER BY s.created_at DESC
        LIMIT ? OFFSET ?
    """
    
    query_params.extend([per_page, (page - 1) * per_page])
    cursor.execute(query, query_params)
    
    # 페이지네이션 계산을 위한 offset
    offset = (page - 1) * per_page
    
    items = []
    for idx, row in enumerate(cursor.fetchall()):
        item = dict(row)
        # No 칼럼은 역순 번호로 설정 (총 개수에서 역순)
        item['no'] = total_count - offset - idx
        
        # custom_data JSON 파싱 및 플래트닝
        if item.get('custom_data'):
            try:
                import json
                custom_data = json.loads(item['custom_data'])
                item.update(custom_data)  # 최상위 레벨에 병합
            except Exception as e:
                logging.error(f"custom_data 파싱 오류: {e}")
        items.append(item)
    
    conn.close()
    
    # smart_apply_mappings 적용 (드롭다운 코드를 라벨로 변환)
    if items:
        from common_mapping import smart_apply_mappings
        items = smart_apply_mappings(items, 'follow_sop', dynamic_columns, DB_PATH)
    
    # 페이지네이션 객체 생성 (app.py와 동일한 구조)
    class Pagination:
        def __init__(self, page, per_page, total_count):
            self.page = page
            self.per_page = per_page
            self.total_count = total_count
            self.pages = math.ceil(total_count / per_page) if total_count > 0 else 1
            self.has_prev = page > 1
            self.prev_num = page - 1 if self.has_prev else None
            self.has_next = page < self.pages
            self.next_num = page + 1 if self.has_next else None
            
        def iter_pages(self, window_size=10):
            start = ((self.page - 1) // window_size) * window_size + 1
            end = min(start + window_size - 1, self.pages)
            for num in range(start, end + 1):
                yield num
        
        def get_window_info(self, window_size=10):
            start = ((self.page - 1) // window_size) * window_size + 1
            end = min(start + window_size - 1, self.pages)
            has_prev_window = start > 1
            has_next_window = end < self.pages
            prev_window_start = max(1, start - window_size)
            next_window_start = min(end + 1, self.pages)
            return {
                'start': start,
                'end': end,
                'has_prev_window': has_prev_window,
                'has_next_window': has_next_window,
                'prev_window_start': prev_window_start,
                'next_window_start': next_window_start
            }
    
    pagination = Pagination(page=page, per_page=per_page, total_count=total_count)
    
    return render_template('follow-sop.html',
                         followsops=items,  # Follow SOP 전용 변수명
                         dynamic_columns=dynamic_columns,
                         sections=sections,
                         section_columns=section_columns,
                         pagination=pagination,
                         search_params=search_params,
                         menu=MENU_CONFIG)

@app.route("/follow-sop-register")
def follow_sop_register():
    """Follow SOP 등록 페이지"""
    import sqlite3
    from timezone_config import get_korean_time_str, get_korean_time
    logging.info("Follow SOP 등록 페이지 접근")
    
    conn = get_db_connection()
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # 섹션 정보 가져오기
    from section_service import SectionConfigService
    section_service = SectionConfigService('follow_sop', DB_PATH)
    
    # 기본 섹션 확인 및 생성
    cursor.execute("SELECT COUNT(*) FROM follow_sop_sections WHERE section_key = 'basic_info'")
    if cursor.fetchone()[0] == 0:
        cursor.execute("""
            INSERT INTO follow_sop_sections (section_key, section_name, section_order, is_active)
            VALUES ('basic_info', '기본정보', 1, 1)
        """)
        conn.commit()
    
    sections = section_service.get_sections()
    
    # 동적 컬럼 설정 가져오기
    cursor.execute("""
        SELECT * FROM follow_sop_column_config 
        WHERE is_active = 1 AND (is_deleted = 0 OR is_deleted IS NULL)
        ORDER BY column_order
    """)
    dynamic_columns_rows = cursor.fetchall()
    dynamic_columns = [dict(row) for row in dynamic_columns_rows]
    
    # 기본정보 필드 추가 (하드코딩) - 자동 생성값 포함
    from id_generator import generate_followsop_number
    from datetime import datetime
    created_at_dt = get_korean_time()
    created_at = created_at_dt.strftime('%Y-%m-%d %H:%M:%S')
    # created_at 기준으로 번호 생성
    work_req_no = generate_followsop_number(DB_PATH, created_at_dt)
    
    # work_req_no는 column_config에 없으므로 하드코딩
    basic_fields = [
        {'column_key': 'work_req_no', 'column_name': '점검번호', 'column_type': 'text', 
         'is_required': 1, 'is_readonly': 1, 'tab': 'basic_info', 'default_value': work_req_no}
    ]
    
    # created_at이 column_config에 있으면 거기서 가져오고 default_value만 설정
    for col in dynamic_columns:
        if col['column_key'] == 'created_at':
            col['default_value'] = created_at
            break
    
    # basic_info의 dynamic_columns 추가
    basic_info_dynamic = [col for col in dynamic_columns if col.get('tab') == 'basic_info']
    basic_fields.extend(basic_info_dynamic)
    
    # 섹션별로 컬럼 분류
    section_columns = {'basic_info': basic_fields}
    for section in sections:
        if section['section_key'] != 'basic_info':
            section_columns[section['section_key']] = [
                col for col in dynamic_columns if col.get('tab') == section['section_key']
            ]
    
    # 디버깅용 로그
    logging.info(f"Follow SOP Register - sections: {sections}")
    logging.info(f"Follow SOP Register - section_columns: {section_columns}")
    logging.info(f"Follow SOP Register - basic_fields: {basic_fields}")
    
    conn.close()
    
    # 팝업 여부 확인
    is_popup = request.args.get('popup') == '1'
    
    # 현재 날짜 추가 (한국 시간)
    from timezone_config import get_korean_time
    today_date = get_korean_time().strftime('%Y-%m-%d')
    
    return render_template('follow-sop-register.html',
                         dynamic_columns=dynamic_columns,
                         sections=sections,
                         section_columns=section_columns,  # 중요! 이것이 누락되어 있었음
                         today_date=today_date,  # 오늘 날짜 추가
                         is_popup=is_popup,
                         menu=MENU_CONFIG)

@app.route("/follow-sop-detail/<work_req_no>")
def follow_sop_detail(work_req_no):
    """Follow SOP 상세정보 페이지"""
    import json
    import sqlite3
    logging.info(f"Follow SOP 상세 정보 조회: {work_req_no}")
    
    conn = get_db_connection()
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # Follow SOP 정보 조회
    cursor.execute("""
        SELECT * FROM follow_sop
        WHERE work_req_no = ?
    """, (work_req_no,))
    
    sop_row = cursor.fetchone()
    if not sop_row:
        conn.close()
        return "Follow SOP를 찾을 수 없습니다.", 404
    
    sop = dict(sop_row)
    
    # custom_data JSON 파싱
    custom_data = {}
    if sop.get('custom_data'):
        try:
            custom_data = json.loads(sop['custom_data'])
            # sop 딕셔너리에 custom_data 병합 (중요!)
            sop.update(custom_data)
        except:
            custom_data = {}
    
    # 섹션별 컬럼 정보 가져오기
    from section_service import SectionConfigService
    section_service = SectionConfigService('follow_sop', DB_PATH)
    sections = section_service.get_sections()
    
    # 동적 컬럼 설정 가져오기
    cursor.execute("""
        SELECT * FROM follow_sop_column_config 
        WHERE is_active = 1 AND (is_deleted = 0 OR is_deleted IS NULL)
        ORDER BY column_order
    """)
    dynamic_columns = [dict(row) for row in cursor.fetchall()]
    
    # 기본정보 필드 추가 (work_req_no만 하드코딩, created_at은 column_config에서 가져옴)
    basic_fields = [
        {'column_key': 'work_req_no', 'column_name': '점검번호', 'column_type': 'text', 
         'is_required': 1, 'is_readonly': 1, 'tab': 'basic_info'}
    ]
    
    # basic_info 섹션의 dynamic_columns 추가 (created_at 포함)
    basic_info_dynamic = [col for col in dynamic_columns if col.get('tab') == 'basic_info']
    basic_fields.extend(basic_info_dynamic)
    
    # 섹션별로 컬럼 분류
    section_columns = {'basic_info': basic_fields}
    for section in sections:
        if section['section_key'] != 'basic_info':
            section_columns[section['section_key']] = [
                col for col in dynamic_columns if col.get('tab') == section['section_key']
            ]
    
    # 디버깅용 로그
    logging.info(f"Follow SOP Detail - sections: {sections}")
    logging.info(f"Follow SOP Detail - section_columns: {section_columns}")
    
    conn.close()
    
    # 팝업 여부 확인
    is_popup = request.args.get('popup') == '1'
    
    return render_template('follow-sop-detail.html',
                         sop=sop,
                         custom_data=custom_data,
                         sections=sections,
                         section_columns=section_columns,
                         is_popup=is_popup,
                         menu=MENU_CONFIG)

@app.route('/register-follow-sop', methods=['POST'])
def register_follow_sop():
    """새 Follow SOP 등록"""
    conn = None
    try:
        # safety-instruction과 동일한 방식으로 form data 처리
        import json
        from timezone_config import get_korean_time_str, get_korean_time
        from db.upsert import safe_upsert
        
        data = json.loads(request.form.get('data', '{}'))
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # created_at 기준으로 work_req_no 생성 (FS + yyMMddhhmm + 카운터)
        from id_generator import generate_followsop_number
        created_at_dt = get_korean_time()
        work_req_no = generate_followsop_number(DB_PATH, created_at_dt)
        
        # follow_sop_cache 테이블이 없으면 생성
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS follow_sop_cache (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                work_req_no TEXT UNIQUE NOT NULL,
                custom_data TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                created_by TEXT,
                updated_by TEXT,
                is_deleted INTEGER DEFAULT 0
            )
        """)
        
        # custom_data 처리
        custom_data = data.get('custom_data', {})
        if isinstance(custom_data, dict):
            import json
            custom_data_json = json.dumps(custom_data, ensure_ascii=False)
        else:
            custom_data_json = custom_data
        
        # 번호 생성에 사용한 동일한 시간으로 created_at 설정
        created_at = created_at_dt.strftime('%Y-%m-%d %H:%M:%S')
        
        # Follow SOP 등록 - safe_upsert 사용
        upsert_data = {
            'work_req_no': work_req_no,
            'custom_data': custom_data_json,
            'created_at': created_at,
            'created_by': session.get('user_id', 'system'),
            'is_deleted': 0
        }
        safe_upsert(conn, 'follow_sop_cache', upsert_data)
        
        conn.commit()
        
        return jsonify({
            'success': True,
            'message': 'Follow SOP가 등록되었습니다.',
            'work_req_no': work_req_no
        })
        
    except Exception as e:
        if conn:
            conn.rollback()
        logging.error(f"Follow SOP 등록 중 오류: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        if conn:
            conn.close()

# 이 라우트는 app.py에 더 완전한 버전이 있으므로 백업으로 변경
# @app.route('/update-follow-sop', methods=['POST'])
def update_follow_sop_simple():
    """Follow SOP 수정"""
    conn = None
    try:
        import json
        
        # safety-instruction과 동일한 방식으로 FormData 받기
        work_req_no = request.form.get('work_req_no')
        detailed_content = request.form.get('detailed_content', '')
        custom_data = request.form.get('custom_data', '{}')
        
        if not work_req_no:
            return jsonify({'success': False, 'message': '점검번호가 필요합니다.'}), 400
        
        # JSON 파싱
        try:
            custom_data_dict = json.loads(custom_data) if custom_data != '{}' else {}
        except ValueError:
            return jsonify({"success": False, "message": "잘못된 데이터 형식입니다."}), 400
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # custom_data에 detailed_content 포함
        if detailed_content:
            custom_data_dict['detailed_content'] = detailed_content
        
        custom_data_json = json.dumps(custom_data_dict, ensure_ascii=False)
        
        # Follow SOP 업데이트
        cursor.execute("""
            UPDATE follow_sop 
            SET custom_data = ?, updated_by = ?
            WHERE work_req_no = ?
        """, (custom_data_json, session.get('user_id', 'system'), work_req_no))
        
        conn.commit()
        
        return jsonify({
            'success': True,
            'message': 'Follow SOP가 수정되었습니다.'
        })
        
    except Exception as e:
        if conn:
            conn.rollback()
        logging.error(f"Follow SOP 수정 중 오류: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        if conn:
            conn.close()

# ============= Full Process 페이지 라우트 =============
@app.route("/full-process")
def full_process_route():
    """Full Process 페이지 라우트"""
    from common_mapping import smart_apply_mappings
    import math
    import sqlite3
    from section_service import SectionConfigService
    
    conn = get_db_connection()
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # 섹션 서비스 초기화
    section_service = SectionConfigService('full_process', DB_PATH)
    
    # 기본 섹션 확인 및 생성
    try:
        cursor.execute("SELECT COUNT(*) FROM full_process_sections WHERE section_key = 'basic_info'")
        if cursor.fetchone()[0] == 0:
            cursor.execute("""
                INSERT INTO full_process_sections (section_key, section_name, section_order, is_active)
                VALUES ('basic_info', '기본정보', 1, 1)
            """)
            conn.commit()
    except Exception as e:
        # 테이블이 없거나 컬럼이 없으면 무시
        conn.rollback() if hasattr(conn, 'rollback') else None
        pass
    
    # 섹션 정보 가져오기
    sections = section_service.get_sections()
    
    # 동적 컬럼 정보 가져오기
    cursor.execute("""
        SELECT * FROM full_process_column_config 
        WHERE is_active = 1 AND (is_deleted = 0 OR is_deleted IS NULL)
        ORDER BY column_order
    """)
    dynamic_columns_rows = cursor.fetchall()
    dynamic_columns = [dict(row) for row in dynamic_columns_rows]
    
    # 섹션별로 컬럼 분류
    section_columns = {}
    for section in sections:
        section_columns[section['section_key']] = [
            col for col in dynamic_columns if col.get('tab') == section['section_key']
        ]
    
    # 페이지네이션 처리
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    
    # 검색 조건 처리
    search_params = {}
    where_clauses = []
    query_params = []
    
    # 기본 검색 필드들
    company_name = request.args.get('company_name', '').strip()
    business_number = request.args.get('business_number', '').strip()
    
    if company_name:
        search_params['company_name'] = company_name
        where_clauses.append("JSON_EXTRACT(p.custom_data, '$.company_1cha') LIKE ?")
        query_params.append(f"%{company_name}%")
    
    if business_number:
        search_params['business_number'] = business_number
        where_clauses.append("JSON_EXTRACT(p.custom_data, '$.company_1cha_bizno') LIKE ?")
        query_params.append(f"%{business_number}%")
    
    # WHERE 절 구성 (삭제되지 않은 항목만)
    where_clauses.insert(0, "(p.is_deleted = 0 OR p.is_deleted IS NULL)")
    where_sql = " AND ".join(where_clauses) if where_clauses else "1=1"
    
    # 전체 건수 조회 - full_process_cache 테이블에서!
    count_query = f"""
        SELECT COUNT(*) 
        FROM full_process_cache p
        WHERE {where_sql}
    """
    
    cursor.execute(count_query, query_params)
    total_count = cursor.fetchone()[0]
    
    # 데이터 조회 - full_process_cache 테이블에서!
    query = f"""
        SELECT p.* 
        FROM full_process_cache p
        WHERE {where_sql}
        ORDER BY p.created_at DESC
        LIMIT ? OFFSET ?
    """
    
    query_params.extend([per_page, (page - 1) * per_page])
    cursor.execute(query, query_params)
    
    # 페이지네이션 계산을 위한 offset  
    offset = (page - 1) * per_page
    
    items = []
    for idx, row in enumerate(cursor.fetchall()):
        item = dict(row)
        # No 칼럼은 역순 번호로 설정 (총 개수에서 역순)
        item['no'] = total_count - offset - idx
        
        # custom_data JSON 파싱 및 플래트닝
        if item.get('custom_data'):
            try:
                import json
                custom_data = json.loads(item['custom_data'])
                item.update(custom_data)  # 최상위 레벨에 병합
            except Exception as e:
                logging.error(f"custom_data 파싱 오류: {e}")
        items.append(item)
    
    conn.close()
    
    # smart_apply_mappings 적용 (드롭다운 코드를 라벨로 변환)
    if items:
        from common_mapping import smart_apply_mappings
        items = smart_apply_mappings(items, 'full_process', dynamic_columns, DB_PATH)
    
    # 페이지네이션 객체 생성 (app.py와 동일한 구조)
    class Pagination:
        def __init__(self, page, per_page, total_count):
            self.page = page
            self.per_page = per_page
            self.total_count = total_count
            self.pages = math.ceil(total_count / per_page) if total_count > 0 else 1
            self.has_prev = page > 1
            self.prev_num = page - 1 if self.has_prev else None
            self.has_next = page < self.pages
            self.next_num = page + 1 if self.has_next else None
            
        def iter_pages(self, window_size=10):
            start = ((self.page - 1) // window_size) * window_size + 1
            end = min(start + window_size - 1, self.pages)
            for num in range(start, end + 1):
                yield num
        
        def get_window_info(self, window_size=10):
            start = ((self.page - 1) // window_size) * window_size + 1
            end = min(start + window_size - 1, self.pages)
            has_prev_window = start > 1
            has_next_window = end < self.pages
            prev_window_start = max(1, start - window_size)
            next_window_start = min(end + 1, self.pages)
            return {
                'start': start,
                'end': end,
                'has_prev_window': has_prev_window,
                'has_next_window': has_next_window,
                'prev_window_start': prev_window_start,
                'next_window_start': next_window_start
            }
    
    pagination = Pagination(page=page, per_page=per_page, total_count=total_count)
    
    return render_template('full-process.html',
                         fullprocesses=items,  # Full Process 전용 변수명
                         dynamic_columns=dynamic_columns,
                         sections=sections,
                         section_columns=section_columns,
                         pagination=pagination,
                         search_params=search_params,
                         menu=MENU_CONFIG)

@app.route("/full-process-register")
def full_process_register():
    """Full Process 등록 페이지"""
    import sqlite3
    from timezone_config import get_korean_time_str, get_korean_time
    logging.info("Full Process 등록 페이지 접근")
    
    conn = get_db_connection()
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # 섹션 서비스 초기화
    from section_service import SectionConfigService
    section_service = SectionConfigService('full_process', DB_PATH)
    
    # 기본 섹션 확인 및 생성
    try:
        cursor.execute("SELECT COUNT(*) FROM full_process_sections WHERE section_key = 'basic_info'")
        if cursor.fetchone()[0] == 0:
            cursor.execute("""
                INSERT INTO full_process_sections (section_key, section_name, section_order, is_active)
                VALUES ('basic_info', '기본정보', 1, 1)
            """)
            conn.commit()
    except Exception as e:
        # 테이블이 없거나 컬럼이 없으면 무시
        conn.rollback() if hasattr(conn, 'rollback') else None
        pass
    
    # 섹션 정보 가져오기
    sections = section_service.get_sections()
    
    # 동적 컬럼 설정 가져오기
    cursor.execute("""
        SELECT * FROM full_process_column_config 
        WHERE is_active = 1 AND (is_deleted = 0 OR is_deleted IS NULL)
        ORDER BY column_order
    """)
    dynamic_columns_rows = cursor.fetchall()
    dynamic_columns = [dict(row) for row in dynamic_columns_rows]
    
    # 기본정보 필드 추가 (하드코딩) - 자동 생성값 포함
    from id_generator import generate_fullprocess_number
    from datetime import datetime
    created_at_dt = get_korean_time()
    created_at = created_at_dt.strftime('%Y-%m-%d %H:%M:%S')
    # created_at 기준으로 번호 생성
    fullprocess_number = generate_fullprocess_number(DB_PATH, created_at_dt)
    
    basic_fields = [
        {'column_key': 'fullprocess_number', 'column_name': '평가번호', 'column_type': 'text', 
         'is_required': 1, 'is_readonly': 1, 'tab': 'basic_info', 'default_value': fullprocess_number},
        {'column_key': 'created_at', 'column_name': '등록일', 'column_type': 'datetime', 
         'is_required': 1, 'is_readonly': 1, 'tab': 'basic_info', 'default_value': created_at}
    ]
    
    # 섹션별로 컬럼 분류
    section_columns = {'basic_info': basic_fields}
    for section in sections:
        if section['section_key'] != 'basic_info':
            section_columns[section['section_key']] = [
                col for col in dynamic_columns if col.get('tab') == section['section_key']
            ]
    
    conn.close()
    
    # 팝업 여부 확인
    is_popup = request.args.get('popup') == '1'
    
    # 현재 날짜 추가 (한국 시간)
    from timezone_config import get_korean_time
    today_date = get_korean_time().strftime('%Y-%m-%d')
    
    return render_template('full-process-register.html',
                         dynamic_columns=dynamic_columns,
                         sections=sections,
                         section_columns=section_columns,  # 중요! 이것이 누락되어 있었음
                         today_date=today_date,  # 오늘 날짜 추가
                         is_popup=is_popup,
                         menu=MENU_CONFIG)

@app.route("/full-process-detail/<fullprocess_number>")
def full_process_detail(fullprocess_number):
    """Full Process 상세정보 페이지"""
    import json
    import sqlite3
    logging.info(f"Full Process 상세 정보 조회: {fullprocess_number}")
    
    conn = get_db_connection()
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # Full Process 정보 조회
    cursor.execute("""
        SELECT * FROM full_process
        WHERE fullprocess_number = ?
    """, (fullprocess_number,))
    
    process_row = cursor.fetchone()
    if not process_row:
        conn.close()
        return "Full Process를 찾을 수 없습니다.", 404
    
    process = dict(process_row)
    
    # custom_data JSON 파싱
    custom_data = {}
    if process.get('custom_data'):
        try:
            custom_data = json.loads(process['custom_data'])
            # process 딕셔너리에 custom_data 병합 (중요!)
            process.update(custom_data)
        except:
            custom_data = {}
    
    # 섹션별 컬럼 정보 가져오기
    from section_service import SectionConfigService
    section_service = SectionConfigService('full_process', DB_PATH)
    sections = section_service.get_sections()
    
    # 동적 컬럼 설정 가져오기
    cursor.execute("""
        SELECT * FROM full_process_column_config 
        WHERE is_active = 1 AND (is_deleted = 0 OR is_deleted IS NULL)
        ORDER BY column_order
    """)
    dynamic_columns = [dict(row) for row in cursor.fetchall()]
    
    # 기본정보 필드 추가 (하드코딩)
    basic_fields = [
        {'column_key': 'fullprocess_number', 'column_name': '평가번호', 'column_type': 'text', 
         'is_required': 1, 'is_readonly': 1, 'tab': 'basic_info'},
        {'column_key': 'created_at', 'column_name': '등록일', 'column_type': 'datetime', 
         'is_required': 1, 'is_readonly': 1, 'tab': 'basic_info'}
    ]
    
    # 섹션별로 컬럼 분류
    section_columns = {'basic_info': basic_fields}
    for section in sections:
        if section['section_key'] != 'basic_info':
            section_columns[section['section_key']] = [
                col for col in dynamic_columns if col.get('tab') == section['section_key']
            ]
    
    conn.close()
    
    # 팝업 여부 확인
    is_popup = request.args.get('popup') == '1'
    
    return render_template('full-process-detail.html',
                         process=process,
                         custom_data=custom_data,
                         sections=sections,
                         section_columns=section_columns,
                         is_popup=is_popup,
                         menu=MENU_CONFIG)

@app.route('/register-full-process', methods=['POST'])
def register_full_process():
    """새 Full Process 등록"""
    conn = None
    try:
        # safety-instruction과 동일한 방식으로 form data 처리
        import json
        from timezone_config import get_korean_time_str, get_korean_time
        from db.upsert import safe_upsert
        
        data = json.loads(request.form.get('data', '{}'))
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # created_at 기준으로 fullprocess_number 생성 (FP + yyMMddhhmm + 카운터)
        from id_generator import generate_fullprocess_number
        created_at_dt = get_korean_time()
        fullprocess_number = generate_fullprocess_number(DB_PATH, created_at_dt)
        
        # full_process_cache 테이블이 없으면 생성
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS full_process_cache (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                fullprocess_number TEXT UNIQUE NOT NULL,
                custom_data TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                created_by TEXT,
                updated_by TEXT,
                is_deleted INTEGER DEFAULT 0
            )
        """)
        
        # custom_data 처리
        custom_data = data.get('custom_data', {})
        if isinstance(custom_data, dict):
            import json
            custom_data_json = json.dumps(custom_data, ensure_ascii=False)
        else:
            custom_data_json = custom_data
        
        # 번호 생성에 사용한 동일한 시간으로 created_at 설정
        created_at = created_at_dt.strftime('%Y-%m-%d %H:%M:%S')
        
        # Full Process 등록 - safe_upsert 사용
        upsert_data = {
            'fullprocess_number': fullprocess_number,
            'custom_data': custom_data_json,
            'created_at': created_at,
            'created_by': session.get('user_id', 'system'),
            'is_deleted': 0
        }
        safe_upsert(conn, 'full_process_cache', upsert_data)
        
        conn.commit()
        
        return jsonify({
            'success': True,
            'message': 'Full Process가 등록되었습니다.',
            'fullprocess_number': fullprocess_number
        })
        
    except Exception as e:
        if conn:
            conn.rollback()
        logging.error(f"Full Process 등록 중 오류: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        if conn:
            conn.close()

# 이 라우트는 app.py에 더 완전한 버전이 있으므로 백업으로 변경
# @app.route('/update-full-process', methods=['POST'])
def update_full_process_simple():
    """Full Process 수정"""
    conn = None
    try:
        import json
        
        # safety-instruction과 동일한 방식으로 FormData 받기
        fullprocess_number = request.form.get('fullprocess_number')
        detailed_content = request.form.get('detailed_content', '')
        custom_data = request.form.get('custom_data', '{}')
        
        if not fullprocess_number:
            return jsonify({'success': False, 'message': 'Process 번호가 필요합니다.'}), 400
        
        # JSON 파싱
        try:
            custom_data_dict = json.loads(custom_data) if custom_data != '{}' else {}
        except ValueError:
            return jsonify({"success": False, "message": "잘못된 데이터 형식입니다."}), 400
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # custom_data에 detailed_content 포함
        if detailed_content:
            custom_data_dict['detailed_content'] = detailed_content
        
        custom_data_json = json.dumps(custom_data_dict, ensure_ascii=False)
        
        # Full Process 업데이트
        cursor.execute("""
            UPDATE full_process 
            SET custom_data = ?, updated_by = ?
            WHERE fullprocess_number = ?
        """, (custom_data_json, session.get('user_id', 'system'), fullprocess_number))
        
        conn.commit()
        
        return jsonify({
            'success': True,
            'message': 'Full Process가 수정되었습니다.'
        })
        
    except Exception as e:
        if conn:
            conn.rollback()
        logging.error(f"Full Process 수정 중 오류: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        if conn:
            conn.close()